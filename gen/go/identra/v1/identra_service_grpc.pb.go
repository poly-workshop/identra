// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v5.29.3
// source: identra/v1/identra_service.proto

package identra_v1_pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	IdentraService_GetJWKS_FullMethodName                  = "/identra.v1.IdentraService/GetJWKS"
	IdentraService_GetOAuthAuthorizationURL_FullMethodName = "/identra.v1.IdentraService/GetOAuthAuthorizationURL"
	IdentraService_LoginByOAuth_FullMethodName             = "/identra.v1.IdentraService/LoginByOAuth"
	IdentraService_BindUserByOAuth_FullMethodName          = "/identra.v1.IdentraService/BindUserByOAuth"
	IdentraService_SendLoginEmailCode_FullMethodName       = "/identra.v1.IdentraService/SendLoginEmailCode"
	IdentraService_LoginByEmailCode_FullMethodName         = "/identra.v1.IdentraService/LoginByEmailCode"
	IdentraService_LoginByPassword_FullMethodName          = "/identra.v1.IdentraService/LoginByPassword"
	IdentraService_RefreshToken_FullMethodName             = "/identra.v1.IdentraService/RefreshToken"
	IdentraService_GetCurrentUserLoginInfo_FullMethodName  = "/identra.v1.IdentraService/GetCurrentUserLoginInfo"
)

// IdentraServiceClient is the client API for IdentraService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IdentraServiceClient interface {
	// GetJWKS returns the JSON Web Key Set for verifying tokens
	GetJWKS(ctx context.Context, in *GetJWKSRequest, opts ...grpc.CallOption) (*GetJWKSResponse, error)
	GetOAuthAuthorizationURL(ctx context.Context, in *GetOAuthAuthorizationURLRequest, opts ...grpc.CallOption) (*GetOAuthAuthorizationURLResponse, error)
	LoginByOAuth(ctx context.Context, in *LoginByOAuthRequest, opts ...grpc.CallOption) (*LoginByOAuthResponse, error)
	BindUserByOAuth(ctx context.Context, in *BindUserByOAuthRequest, opts ...grpc.CallOption) (*BindUserByOAuthResponse, error)
	SendLoginEmailCode(ctx context.Context, in *SendLoginEmailCodeRequest, opts ...grpc.CallOption) (*SendLoginEmailCodeResponse, error)
	LoginByEmailCode(ctx context.Context, in *LoginByEmailCodeRequest, opts ...grpc.CallOption) (*LoginByEmailCodeResponse, error)
	LoginByPassword(ctx context.Context, in *LoginByPasswordRequest, opts ...grpc.CallOption) (*LoginByPasswordResponse, error)
	RefreshToken(ctx context.Context, in *RefreshTokenRequest, opts ...grpc.CallOption) (*RefreshTokenResponse, error)
	// GetCurrentUserLoginInfo returns the current user's linked login methods,
	// e.g. bound email and OAuth provider identifiers.
	GetCurrentUserLoginInfo(ctx context.Context, in *GetCurrentUserLoginInfoRequest, opts ...grpc.CallOption) (*GetCurrentUserLoginInfoResponse, error)
}

type identraServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewIdentraServiceClient(cc grpc.ClientConnInterface) IdentraServiceClient {
	return &identraServiceClient{cc}
}

func (c *identraServiceClient) GetJWKS(ctx context.Context, in *GetJWKSRequest, opts ...grpc.CallOption) (*GetJWKSResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetJWKSResponse)
	err := c.cc.Invoke(ctx, IdentraService_GetJWKS_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *identraServiceClient) GetOAuthAuthorizationURL(ctx context.Context, in *GetOAuthAuthorizationURLRequest, opts ...grpc.CallOption) (*GetOAuthAuthorizationURLResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetOAuthAuthorizationURLResponse)
	err := c.cc.Invoke(ctx, IdentraService_GetOAuthAuthorizationURL_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *identraServiceClient) LoginByOAuth(ctx context.Context, in *LoginByOAuthRequest, opts ...grpc.CallOption) (*LoginByOAuthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginByOAuthResponse)
	err := c.cc.Invoke(ctx, IdentraService_LoginByOAuth_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *identraServiceClient) BindUserByOAuth(ctx context.Context, in *BindUserByOAuthRequest, opts ...grpc.CallOption) (*BindUserByOAuthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BindUserByOAuthResponse)
	err := c.cc.Invoke(ctx, IdentraService_BindUserByOAuth_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *identraServiceClient) SendLoginEmailCode(ctx context.Context, in *SendLoginEmailCodeRequest, opts ...grpc.CallOption) (*SendLoginEmailCodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendLoginEmailCodeResponse)
	err := c.cc.Invoke(ctx, IdentraService_SendLoginEmailCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *identraServiceClient) LoginByEmailCode(ctx context.Context, in *LoginByEmailCodeRequest, opts ...grpc.CallOption) (*LoginByEmailCodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginByEmailCodeResponse)
	err := c.cc.Invoke(ctx, IdentraService_LoginByEmailCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *identraServiceClient) LoginByPassword(ctx context.Context, in *LoginByPasswordRequest, opts ...grpc.CallOption) (*LoginByPasswordResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginByPasswordResponse)
	err := c.cc.Invoke(ctx, IdentraService_LoginByPassword_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *identraServiceClient) RefreshToken(ctx context.Context, in *RefreshTokenRequest, opts ...grpc.CallOption) (*RefreshTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RefreshTokenResponse)
	err := c.cc.Invoke(ctx, IdentraService_RefreshToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *identraServiceClient) GetCurrentUserLoginInfo(ctx context.Context, in *GetCurrentUserLoginInfoRequest, opts ...grpc.CallOption) (*GetCurrentUserLoginInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCurrentUserLoginInfoResponse)
	err := c.cc.Invoke(ctx, IdentraService_GetCurrentUserLoginInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IdentraServiceServer is the server API for IdentraService service.
// All implementations must embed UnimplementedIdentraServiceServer
// for forward compatibility.
type IdentraServiceServer interface {
	// GetJWKS returns the JSON Web Key Set for verifying tokens
	GetJWKS(context.Context, *GetJWKSRequest) (*GetJWKSResponse, error)
	GetOAuthAuthorizationURL(context.Context, *GetOAuthAuthorizationURLRequest) (*GetOAuthAuthorizationURLResponse, error)
	LoginByOAuth(context.Context, *LoginByOAuthRequest) (*LoginByOAuthResponse, error)
	BindUserByOAuth(context.Context, *BindUserByOAuthRequest) (*BindUserByOAuthResponse, error)
	SendLoginEmailCode(context.Context, *SendLoginEmailCodeRequest) (*SendLoginEmailCodeResponse, error)
	LoginByEmailCode(context.Context, *LoginByEmailCodeRequest) (*LoginByEmailCodeResponse, error)
	LoginByPassword(context.Context, *LoginByPasswordRequest) (*LoginByPasswordResponse, error)
	RefreshToken(context.Context, *RefreshTokenRequest) (*RefreshTokenResponse, error)
	// GetCurrentUserLoginInfo returns the current user's linked login methods,
	// e.g. bound email and OAuth provider identifiers.
	GetCurrentUserLoginInfo(context.Context, *GetCurrentUserLoginInfoRequest) (*GetCurrentUserLoginInfoResponse, error)
	mustEmbedUnimplementedIdentraServiceServer()
}

// UnimplementedIdentraServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedIdentraServiceServer struct{}

func (UnimplementedIdentraServiceServer) GetJWKS(context.Context, *GetJWKSRequest) (*GetJWKSResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetJWKS not implemented")
}
func (UnimplementedIdentraServiceServer) GetOAuthAuthorizationURL(context.Context, *GetOAuthAuthorizationURLRequest) (*GetOAuthAuthorizationURLResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetOAuthAuthorizationURL not implemented")
}
func (UnimplementedIdentraServiceServer) LoginByOAuth(context.Context, *LoginByOAuthRequest) (*LoginByOAuthResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LoginByOAuth not implemented")
}
func (UnimplementedIdentraServiceServer) BindUserByOAuth(context.Context, *BindUserByOAuthRequest) (*BindUserByOAuthResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method BindUserByOAuth not implemented")
}
func (UnimplementedIdentraServiceServer) SendLoginEmailCode(context.Context, *SendLoginEmailCodeRequest) (*SendLoginEmailCodeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SendLoginEmailCode not implemented")
}
func (UnimplementedIdentraServiceServer) LoginByEmailCode(context.Context, *LoginByEmailCodeRequest) (*LoginByEmailCodeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LoginByEmailCode not implemented")
}
func (UnimplementedIdentraServiceServer) LoginByPassword(context.Context, *LoginByPasswordRequest) (*LoginByPasswordResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LoginByPassword not implemented")
}
func (UnimplementedIdentraServiceServer) RefreshToken(context.Context, *RefreshTokenRequest) (*RefreshTokenResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RefreshToken not implemented")
}
func (UnimplementedIdentraServiceServer) GetCurrentUserLoginInfo(context.Context, *GetCurrentUserLoginInfoRequest) (*GetCurrentUserLoginInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCurrentUserLoginInfo not implemented")
}
func (UnimplementedIdentraServiceServer) mustEmbedUnimplementedIdentraServiceServer() {}
func (UnimplementedIdentraServiceServer) testEmbeddedByValue()                        {}

// UnsafeIdentraServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IdentraServiceServer will
// result in compilation errors.
type UnsafeIdentraServiceServer interface {
	mustEmbedUnimplementedIdentraServiceServer()
}

func RegisterIdentraServiceServer(s grpc.ServiceRegistrar, srv IdentraServiceServer) {
	// If the following call panics, it indicates UnimplementedIdentraServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&IdentraService_ServiceDesc, srv)
}

func _IdentraService_GetJWKS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetJWKSRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IdentraServiceServer).GetJWKS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IdentraService_GetJWKS_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IdentraServiceServer).GetJWKS(ctx, req.(*GetJWKSRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IdentraService_GetOAuthAuthorizationURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOAuthAuthorizationURLRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IdentraServiceServer).GetOAuthAuthorizationURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IdentraService_GetOAuthAuthorizationURL_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IdentraServiceServer).GetOAuthAuthorizationURL(ctx, req.(*GetOAuthAuthorizationURLRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IdentraService_LoginByOAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginByOAuthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IdentraServiceServer).LoginByOAuth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IdentraService_LoginByOAuth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IdentraServiceServer).LoginByOAuth(ctx, req.(*LoginByOAuthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IdentraService_BindUserByOAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BindUserByOAuthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IdentraServiceServer).BindUserByOAuth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IdentraService_BindUserByOAuth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IdentraServiceServer).BindUserByOAuth(ctx, req.(*BindUserByOAuthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IdentraService_SendLoginEmailCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendLoginEmailCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IdentraServiceServer).SendLoginEmailCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IdentraService_SendLoginEmailCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IdentraServiceServer).SendLoginEmailCode(ctx, req.(*SendLoginEmailCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IdentraService_LoginByEmailCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginByEmailCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IdentraServiceServer).LoginByEmailCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IdentraService_LoginByEmailCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IdentraServiceServer).LoginByEmailCode(ctx, req.(*LoginByEmailCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IdentraService_LoginByPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginByPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IdentraServiceServer).LoginByPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IdentraService_LoginByPassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IdentraServiceServer).LoginByPassword(ctx, req.(*LoginByPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IdentraService_RefreshToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefreshTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IdentraServiceServer).RefreshToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IdentraService_RefreshToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IdentraServiceServer).RefreshToken(ctx, req.(*RefreshTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IdentraService_GetCurrentUserLoginInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCurrentUserLoginInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IdentraServiceServer).GetCurrentUserLoginInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IdentraService_GetCurrentUserLoginInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IdentraServiceServer).GetCurrentUserLoginInfo(ctx, req.(*GetCurrentUserLoginInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// IdentraService_ServiceDesc is the grpc.ServiceDesc for IdentraService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var IdentraService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "identra.v1.IdentraService",
	HandlerType: (*IdentraServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetJWKS",
			Handler:    _IdentraService_GetJWKS_Handler,
		},
		{
			MethodName: "GetOAuthAuthorizationURL",
			Handler:    _IdentraService_GetOAuthAuthorizationURL_Handler,
		},
		{
			MethodName: "LoginByOAuth",
			Handler:    _IdentraService_LoginByOAuth_Handler,
		},
		{
			MethodName: "BindUserByOAuth",
			Handler:    _IdentraService_BindUserByOAuth_Handler,
		},
		{
			MethodName: "SendLoginEmailCode",
			Handler:    _IdentraService_SendLoginEmailCode_Handler,
		},
		{
			MethodName: "LoginByEmailCode",
			Handler:    _IdentraService_LoginByEmailCode_Handler,
		},
		{
			MethodName: "LoginByPassword",
			Handler:    _IdentraService_LoginByPassword_Handler,
		},
		{
			MethodName: "RefreshToken",
			Handler:    _IdentraService_RefreshToken_Handler,
		},
		{
			MethodName: "GetCurrentUserLoginInfo",
			Handler:    _IdentraService_GetCurrentUserLoginInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "identra/v1/identra_service.proto",
}
